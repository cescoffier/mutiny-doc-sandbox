--- 
    layout: base 
---

<section class="hero">
    <div class="hero-main container">
        <div class="row">
            <div class="hero-left col-6">
                <div class="hero-slogan">
                    <h1 class="hero-name">SmallRye Mutiny!&nbsp;</h1>
                    <span class="hero-description">Event-Driven Reactive Programming</span>
                </div>
                <div class="hero-buttons">
                    <a href="getting-started" class="btn btn-rounded button button-dark button-rounded">
                Let's get started&nbsp;<i class="far fa-arrow-alt-circle-right"></i></a>
                </div>
            </div>
            <div class="hero-right col-6">
                <div class="hero-code">
                    <div class="code-examples">
                        <pre><code class="hljs java">
Uni&lt;String&gt; request = ...;
Uni&lt;String&gt; uni = request
    .ifNoItem().after(ofSecond(1)).fail()
    .onFailure().retry().atMost(3)
    .onItem().transform(this::processResponse)
                    </code></pre>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

<section class="characteristics">
    <div class="characteristics-main container">
        <div class="row">
            <div class="characteristic-item col-4">
                <span class="characteristic-item-icon"><i class="fas fa-bolt"></i></span>
                <h5>Event-Driven</h5>
                <p>Mutiny places <em>events</em> at the core of its design. With Mutiny, you observe <em>events</em> and react to them. You create processing pipeline elegantly and easily.</p>
            </div>

            <div class="characteristic-item col-4">
                <span class="characteristic-item-icon"><i class="fas fa-route"></i></span>
                <h5>Navigable</h5>
                <p>Classes with hundred methods are confusing. Mutiny provides a navigable and explicit API describing driving you towards the operator you need.</p>
            </div>

            <div class="characteristic-item col-4">
                <span class="characteristic-item-icon"><i class="fas fa-network-wired"></i></span>
                <h5>Non-Blocking I/O</h5>
                <p>Mutiny is the perfect companion to tame the asynchronous nature of applications using non-blocking I/O. Listen for events and react.</p>
            </div>

            <div class="characteristic-item col-4">
                <span class="characteristic-item-icon"><img class="characteristic-quarkus-logo" src="{{ '/assets/images/quarkus.png' | relative_url }}"/></span>
                <h5>Quarkus but not only</h5>
                <p>Mutiny is integrated in Quarkus. Every reactive API in Quarkus uses Mutiny. But, Mutiny is not limited to Quarkus and can be used in any Java application. Just add it to your classpath, and you're ready!</p>
            </div>

            <div class="characteristic-item col-4">
                <span class="characteristic-item-icon"><i class="fas fa-envelope"></i></span>
                <h5>Everything asynchronous</h5>
                <p>Mutiny can be used in any asynchronous application such as event-driven microservice, message-based applications, network utilities, data stream processing, and, of course, reactive applications.</p>
            </div>

            <div class="characteristic-item col-4">
                <span class="characteristic-item-icon"><i class="fas fa-exchange-alt"></i></span>
                <h5>Reactive Converters Built-In</h5>
                <p>Mutiny is based on Reactive Streams and so can be integrated with any other reactive programming library. In addition, it proposes <em>converters</em> to interact with other popular libraries.</p>
            </div>
        </div>
    </div>
</section>