<!doctype html>
<html lang="en">

<head>
    <title></title>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="SmallRye Mutiny!">

    <link rel="canonical" href="/pages/philosophy.html">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.3.1/styles/default.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/components/icon.min.css" integrity="sha512-8Tb+T7SKUFQWOPIQCaLDWWe1K/SY8hvHl7brOH8Nz5z1VT8fnf8B+9neoUzmFY3OzkWMMs3OjrwZALgB1oXFBg==" crossorigin="anonymous" />
    <link rel="shortcut icon" type="image/png" href="/mutiny-doc-sandbox/assets/images/favicon.ico">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" integrity="sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2" crossorigin="anonymous">
    <link rel="stylesheet" href="/mutiny-doc-sandbox/assets/css/main.css" />
<!--    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/all.css" integrity="sha384-lKuwvrZot6UHsBSfcMvOkWwlCMgc0TaWr+30HWe3a4ltaBwTZhyTEggF5tJv8tbt" crossorigin="anonymous">-->
    <link rel="stylesheet" href="https://maxst.icons8.com/vue-static/landings/line-awesome/font-awesome-line-awesome/css/all.min.css">
    <link rel="stylesheet" href="https://maxst.icons8.com/vue-static/landings/line-awesome/line-awesome/1.3.0/css/line-awesome.min.css">
<!--    <script src="https://kit.fontawesome.com/630fce6bad.js" crossorigin="anonymous"></script>-->
</head>

<body>

    <div class="container-fluid global-container ">
        <main>
            <header class="header">
    <div class="container header-container">
        <div class="row">
            <div class="col-5">
                <a class="brand" href="/mutiny-doc-sandbox/index.html"><strong>Mutiny!</strong></a>
            </div>
            <div class="col-7">
                <nav id="nav" class="nav nav-masthead justify-content-right">
                    <a class="nav-link active" href="/mutiny-doc-sandbox/index.html">Home</a>
                    <a class="nav-link" href="/mutiny-doc-sandbox/getting-started/getting-started">Getting Started</a>
                    <a class="nav-link" href="/mutiny-doc-sandbox/pages/philosophy.html">Concepts</a>
                    <a class="nav-link" href="#">Documentation</a>
                    <a href="https://github.com/smallrye/smallrye-mutiny" target="_blank" title="Github"><i class="lab la-github la-2x"></i></a>
                    <a href="https://stackoverflow.com/questions/tagged/mutiny" target="_blank" title="Stack Overflow"><i class="lab la-stack-overflow la-2x"></i></a>
                </nav>
            </div>
        </div>
    </div>
</header>
            <div class="content">
                <div class="container page-content">
<div class="row">    
    <div class="col-md-8">
        <div class="sect1">
<h2 id="concepts-philosophy"><a class="anchor" href="#concepts-philosophy"></a>Concepts &amp; Philosophy</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Mutiny is a novel reactive programming library.
It provides a simple but powerful asynchronous development model that lets you build reactive applications.</p>
</div>
<div class="paragraph">
<p>Mutiny can be used in any Java application exhibiting asynchrony. From reactive microservices, data streaming, event processing to API gateway, and network utility, Mutiny is a great fit.</p>
</div>
<div class="sect2">
<h3 id="why-is-asynchronous-important"><a class="anchor" href="#why-is-asynchronous-important"></a>Why is asynchronous important?</h3>
<div class="paragraph">
<p>We are living in a distributed worlds.
Most of the applications built nowadays are distributed systems.
The Cloud, IoT, microservices, mobile application, even simple CRUD applications are distributed applications.
But, distributed systems are challenging.</p>
</div>
<div class="imageblock left">
<div class="content">
<img src="/mutiny-doc-sandbox/assets/images/distributed-system-blueprint.png" alt="distributed system blueprint">
</div>
<div class="title">Figure 1. Distributed systems are asynchronous</div>
</div>
<div class="paragraph">
<p>Their nature is inherently asynchronous and wild.
Anything can go wrong unexpectedly.
Network disruptions, unavailable services, software, or hardware failures are just a tiny subset of the wide variety of failures that can happen in distributed systems.</p>
</div>
<div class="paragraph">
<p>Building distributed applications correctly is a considerable challenge.
It requires reassessing almost everything we know about development.</p>
</div>
<div class="paragraph">
<p>Typically, most applications use a synchronous development model.
Synchronous is easy to reason about, more comfortable to write and read, but it has some hidden cost.
This cost emerges when building I/O intensive applications, quite common in distributed applications.
In general, these traditional applications assign one thread per request, and so to handle multiple requests concurrently requires multiple threads.
When the request processing needs to interact over the network, it uses that <em>worker</em> thread, which blocks the thread until the response&#8217;s reception.
This response may never come, so you need to add watchdogs handling timeouts and other resilience patterns.
And, to handle more requests concurrently, you need to create more threads.
But this is not without a cost.
Each thread requires memory, and also, the more threads you have, the more CPU cycles are used to handle the context switches. Thus, this model ends up being costly, limits the deployment density, and on the Cloud means $$$.
Fortunately, there is another way.
That way relies on non-blocking I/O, an efficient way to handle I/O interactions that do not require additional threads.
While applications using non-blocking I/O are more efficient and better suited for the Cloud&#8217;s distributed nature, they come with a considerable constraint: You must never block the I/O thread.
Thus, you need to implement your business logic using an asynchronous development model.</p>
</div>
<div class="paragraph">
<p>I/O is not the only reason why asynchronous is essential in Today&#8217;s systems. Most of the interactions in the real world are asynchronous and event-driven. Representing these interactions using synchronous processes is not only wrong; it also introduces fragility in your application.</p>
</div>
<div class="paragraph">
<p>Asynchronous is a shift.
But, Mutiny helps you to take the plunge.</p>
</div>
</div>
<div class="sect2">
<h3 id="whats-reactive-programming"><a class="anchor" href="#whats-reactive-programming"></a>What&#8217;s Reactive Programming</h3>
<div class="paragraph">
<p>As said above, Mutiny is a reactive programming library.
If you look on Wikipedia for reactive programming, you will find the following definition:</p>
</div>
<div class="quoteblock">
<blockquote>
Reactive Programming combines functional programming, the observer pattern, and the iterable pattern.
</blockquote>
</div>
<div class="paragraph">
<p>While correct, we never found this definition very helpful.
It does not convey clearly what&#8217;s reactive programming is all about.
So, let&#8217;s make another definition, much more straightforward:</p>
</div>
<div class="quoteblock">
<blockquote>
Reactive programming is about programming with data streams.
</blockquote>
</div>
<div class="paragraph">
<p>That&#8217;s it.
Reactive programming is about streams and especially, observing them.
It pushes that idea to its limit: with reactive programming, everything is a data stream.</p>
</div>
<div class="paragraph">
<p>With reactive programming, you observe streams implement side-effects when <em>something</em> flows in the stream:</p>
</div>
<div class="imageblock center">
<div class="content">
<img src="/mutiny-doc-sandbox/assets/images/streams.png" alt="streams">
</div>
<div class="title">Figure 2. Reactive programming is about observing streams</div>
</div>
<div class="paragraph">
<p>It&#8217;s asynchronous by nature as you don&#8217;t know when the <em>data</em> is going to be seen.
Yet, reactive programming goes beyond this.
It provides a toolbox to compose streams and process events.</p>
</div>
</div>
<div class="sect2">
<h3 id="what-makes-mutiny-different"><a class="anchor" href="#what-makes-mutiny-different"></a>What makes Mutiny different?</h3>
<div class="paragraph">
<p>There are other reactive programming libraries out there.
In the Java world,  we can mention Project Reactor and Rx Java.
So, what makes Mutiny different from these two well-known libraries?
Its API.</p>
</div>
<div class="paragraph">
<p>As said above, asynchronous is hard to grasp for most developers.
Thus, the API must not require advanced knowledge or add cognitive overload. It should help you design your logic and be understandable in 6 months.</p>
</div>
<div class="paragraph">
<p>To achieve this, Mutiny is built on three pillars:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Event-Driven</strong> - with Mutiny, you listen for <em>events</em> and handle them,</p>
</li>
<li>
<p><strong>API Navigability</strong> - based on the event-driven nature, the API is built around the type of events and drive the navigation based on the kind of event you want to handle,</p>
</li>
<li>
<p><strong>Simplicity</strong> - Mutiny provides only two types (<code>Multi</code> and <code>Uni</code>), which can handle any kind of asynchronous interactions.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="events"><a class="anchor" href="#events"></a>Events</h3>
<div class="paragraph">
<p>When you use Mutiny, you design a pipeline in which the events flow.
Your code observes these events and react.
Each processing stage is a new pipe you append to the pipeline. This pipe may change the events, create new ones, drops, buffers, whatever you need.</p>
</div>
<div class="paragraph">
<p>In general, events flow from upstream to downstream, from source to sinks.
Some events can <em>swim</em> upstream from the sinks to the source.</p>
</div>
<div class="paragraph">
<p>Events going from upstream to downstream are published by <code>Publishers</code> and consumed by (downstream) <code>Subscribers,</code> which may also produce events for their own downstream, as illustrated by the following diagram:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="/mutiny-doc-sandbox/assets/images/diag-4e60926db2b100a45f7a3fafb6d1c2c5.png" alt="Diagram" width="1268" height="817">
</div>
</div>
<div class="paragraph">
<p>Four types of events can flow in this direction:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Subscribed</strong> - indicate that the upstream has taken into account the subscription - more on this later,</p>
</li>
<li>
<p><strong>Items</strong> - events containing some (business) <em>value</em>,</p>
</li>
<li>
<p><strong>Completion</strong> - event indicating that the source won&#8217;t emit any more items,</p>
</li>
<li>
<p><strong>Failure</strong> - event telling that something terrible happened upstream and that the source cannot continue to emit items.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>Failure</code> and <code>Completion</code> are terminal events.
Once they are sent, no more items will flow.</p>
</div>
<div class="paragraph">
<p>Three types of events flow in the opposite direction, <em>i.e.</em> from downstream to upstream:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Subscription</strong> - event sent by a <em>subscriber</em> to indicate its interest for the events (such as items) emitted by upstream</p>
</li>
<li>
<p><strong>Requests</strong> - event sent by a <em>subscriber</em> indicating how many items event it can handle - this is related to back-pressure</p>
</li>
<li>
<p><strong>Cancellation</strong> - event sent by a <em>subscriber</em> to stop the reception of events.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In a typical scenario, a subscriber:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A subscriber <em>subscribes</em> to the upstream - the upstream receive the subscription <code>subscription request</code>, and when initialized sends the <code>subscribed</code> event to the subscriber</p>
</li>
<li>
<p>The subscriber gets the <code>subscribed</code> event with a <em>subscription</em> used to emit the <code>requests</code> and <code>cancellation</code> events</p>
</li>
<li>
<p>The subscriber sends a <code>request</code> event indicating how many items it can handle at this moment; it can request 1, <em>n</em>, or infinite.</p>
</li>
<li>
<p>The publisher receiving the <code>request</code> event start emitting at most <em>n</em> item events to the subscriber</p>
</li>
<li>
<p>The subscriber can decide at any time to request more events or to cancel the subscription</p>
</li>
</ol>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="/mutiny-doc-sandbox/assets/images/diag-c06139c2b31470fa367c3f84a6e51430.png" alt="Diagram" width="994" height="878">
</div>
</div>
<div class="paragraph">
<p>The <code>request</code> event is the cornerstone of the back-pressure protocol.
A subscriber should not request more than what it can handle, and a publisher should not emit more items than the amount of request received.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Reactive Streams</div>
<div class="paragraph">
<p>Mutiny&#8217;s back-pressure is based on Reactive Streams.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="title">Don&#8217;t forget to subscribe</div>
<div class="paragraph">
<p>If no subscriber <em>subscribes</em>, no items would be emitted. More importantly, nothing will ever happen.
If your program does not do anything, check that it subscribes, it&#8217;s a very common error.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="an-event-driven-api"><a class="anchor" href="#an-event-driven-api"></a>An event-driven API</h3>
<div class="paragraph">
<p>Mutiny is an event-driven API.
For each type of event, there is an <code>on</code> associated method that lets you handle this specific event.
For example:</p>
</div>
<div class="listingblock">
<div class="title">The various types of events</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Multi&lt;String&gt; source = Multi.createFrom().items("a", "b", "c");
source
  .onItem() // Called for every item
    .invoke(item -&gt; log("Received item " + item))
  .onFailure() // Called on failure
    .invoke(failure -&gt; log("Failed with " + failure))
  .onCompletion() // Called when the stream completes
    .invoke(() -&gt; log("Completed"))
  .onSubscribe() // Called the the upstream is ready
    .invoke(subscription -&gt; log("We are subscribed!"))
  .onCancellation() // Called when the downstream cancels
    .invoke(() -&gt; log("Cancelled :-("))
  .onRequest() // Call on downstream requests
    .invoke(n -&gt; log("Downstream requested " + n + " items"))
  .subscribe()
    .with(item -&gt; log("Subscriber received " + item));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course, the methods presented in this snippet are not very interesting, although they are quite useful to trace what&#8217;s going on.</p>
</div>
<div class="paragraph">
<p>You can see a common pattern emerging:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">onEvent().invoke(event -&gt; ...)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>invoke</code> is just one of the methods available.
Each <em>group</em> proposes methods specific to the type of event. For example, <code>onFailure().recover</code>, <code>onCompletion().continueWith</code> and so on.</p>
</div>
</div>
<div class="sect2">
<h3 id="uni-and-multi"><a class="anchor" href="#uni-and-multi"></a>Uni and Multi</h3>
<div class="paragraph">
<p>Mutiny defines two <em>reactive</em> types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Multi</code> - represent streams of <em>0..*</em> items (potentially unbounded)</p>
</li>
<li>
<p><code>Uni</code> - represent streams receiving either an item or a failure</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The Mutiny name comes from the contraction of <code>Multi</code> and <code>Uni</code> names
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Both <code>Uni</code> and <code>Multi</code> are asynchronous types.
They receive and fire events at any time.</p>
</div>
<div class="paragraph">
<p>You may wonder why we make the distinction between <code>Uni</code> and <code>Multi.</code>
Conceptually, a <code>Uni</code> is a <code>Multi,</code> right?
In practice, you don&#8217;t use <code>Unis</code> and <code>Multis</code> the same way.
The use case and operations are different.
Also, <code>Uni</code> does not need the complete ceremony presented above as the <em>request</em> does not make sense.
The <code>subscribe</code> event expresses the interest and triggers the computation, no need for an additional <em>request</em>.
Also, <code>Uni</code> can handle items having a <code>null</code> items (and has specific methods to handle this case).
<code>Multi</code> does not allow it (because the Reactive Streams specification forbids it).</p>
</div>
<div class="paragraph">
<p>Also, having a <code>Uni</code> implementing <code>Publisher</code> would be a bit like having <code>Optional</code> implementing <code>Iterable.</code></p>
</div>
<div class="paragraph">
<p>In other words, <code>Uni</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>can receive at most 1 <code>item</code> event, or a <code>failure</code> event</p>
</li>
<li>
<p>cannot receive a <code>completion</code> event (<code>null</code> in the case of 0 items)</p>
</li>
<li>
<p>cannot receive a <code>request</code> event</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following snippet shows how you can use <code>Uni</code> and <code>Multi</code>:</p>
</div>
<div class="listingblock">
<div class="title">Usage of Uni and Multi</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Multi.createFrom().items("a", "b", "c")
  .onItem().transform(String::toUpperCase)
  .subscribe().with(
    item -&gt; System.out.println("Received: " + item),
    failure -&gt; System.out.println("Failed with " + failure)
);

Uni.createFrom().item("a")
  .onItem().transform(String::toUpperCase)
  .subscribe().with(
    item -&gt; System.out.println("Received: " + item),
    failure -&gt; System.out.println("Failed with " + failure)
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can convert <code>Unis</code> to <code>Multis</code> and vice-versa:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Multi.createFrom().items("a", "b", "c")
  .onItem().transform(String::toUpperCase)
  // Convert the multi to uni
  // It only emits the first item ("a")
  .toUni()
    .subscribe().with(
      item -&gt; System.out.println("Received: " + item),
      failure -&gt; System.out.println("Failed with " + failure);

Uni.createFrom().item("a")
  .onItem().transform(String::toUpperCase)
  // Convert the uni to a multi,
  // the completion event will be fired after "a":
  .toMulti()
  .subscribe().with(
    item -&gt; System.out.println("Received: " + item),
    failure -&gt; System.out.println("Failed with " + failure);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="creating-and-subscribing-to-unis"><a class="anchor" href="#creating-and-subscribing-to-unis"></a>Creating and Subscribing to Unis</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are many ways to create instances of <code>Unis</code>:</p>
</div>
<div class="listingblock">
<div class="title">Creating Unis</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// Creation from a known item, or computed at subscription time
Uni.createFrom()
  .item("some known value");
Uni.createFrom()
  .item(() -&gt; "some value computed at subscription time");

// Creation from a completion stage or completable future
Uni.createFrom()
    .completionStage(CompletableFuture.supplyAsync(() -&gt; "x"))
    .subscribe().with(
            item -&gt; System.out.println("Received: " + item),
            failure -&gt; System.out.println("Failed with " + failure);

// Creation from a failure
Uni.createFrom()
  .failure(() -&gt; new Exception(
    "exception created at subscription time")
  );

// Creation from an emitter
Uni.createFrom().emitter(emitter -&gt; {
    // ...
    emitter.complete("some result");
    //...
});

// Create from a Reactive Streams Publisher or a Multi
Uni.createFrom().publisher(Multi.createFrom()
  .ticks().every(Duration.ofMillis(1)))
  .subscribe().with(
    item -&gt; System.out.println("Received tick " + item),
    failure -&gt; System.out.println("Failed with " + failure)
);

// Defer the creation of the uni until subscription time
Uni.createFrom().deferred(() -&gt; Uni.createFrom()
    .item("create the uni at subscription time"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Subscribing to <code>Unis</code> is done by method provided by <code>uni.subscribe()</code>:</p>
</div>
<div class="listingblock">
<div class="title">Subscribing to Unis</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Uni&lt;String&gt; uni = Uni.createFrom().item("hello");

// Passing callbacks
Cancellable cancellable = uni.subscribe().with(
  item -&gt; System.out.println("Got item: " + item),
  failure -&gt; System.out.println("Got a failure " + failure));
// You can use the returned `cancellation` to cancel
// the computation.
cancellable.cancel();

uni.subscribe().withSubscriber(new UniSubscriber&lt;String&gt;() {
    @Override
    public void onSubscribe(UniSubscription subscription) {
        System.out.println("Got the subscription: "
         + subscription);
    }

    @Override
    public void onItem(String item) {
        System.out.println("Got the item: " + item);
    }

    @Override
    public void onFailure(Throwable failure) {
        System.out.println("Got the failure: " + failure);
    }
});</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="creating-and-subscribing-to-multis"><a class="anchor" href="#creating-and-subscribing-to-multis"></a>Creating and Subscribing to Multis</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are many ways to create instances of <code>Multis</code>:</p>
</div>
<div class="listingblock">
<div class="title">Creating Multis</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// Creation from a known item(s), or computed at
// subscription time
Multi.createFrom().item("some known value");
Multi.createFrom()
  .item(() -&gt; "some value computed at subscription time");
Multi.createFrom().items("a", "b", "c");
Multi.createFrom()
  .items(() -&gt; Stream.of("computed", "at", "subscription", "time"));
Multi.createFrom()
  .iterable(Arrays.asList("some", "iterable"));

// Creation from a completion stage or completable future
Multi.createFrom()
  .completionStage(CompletableFuture.supplyAsync(() -&gt; "x"))
  .subscribe().with(
    item -&gt; System.out.println("Received: " + item),
    failure -&gt; System.out.println("Failed with " + failure));

// Creation from a failure
Multi.createFrom()
  .failure(() -&gt; new Exception("exception created at subscription time"));

// Creation from an emitter
Multi.createFrom().emitter(emitter -&gt; {
    // ...
    emitter.emit("a");
    emitter.emit("b");
    emitter.complete();
    //...
});

// Create from a Reactive Streams Publisher or a Multi
Multi.createFrom()
  .publisher(Multi.createFrom().ticks().every(Duration.ofMillis(1)))
  .transform().byTakingFirstItems(2)
  .subscribe().with(
    item -&gt; System.out.println("Received tick " + item),
    failure -&gt; System.out.println("Failed with " + failure));

// Defer the creation of the uni until subscription time
Multi.createFrom()
  .deferred(() -&gt; Multi.createFrom()
    .item("create the uni at subscription time"));

// Created from a Uni
Multi.createFrom().uni(Uni.createFrom().item("hello"));

// Created from periodic ticks
Multi.createFrom().ticks().every(Duration.ofMillis(1))
        .transform().byTakingFirstItems(2);

// Created from integer range
Multi.createFrom().range(1, 11);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Subscribing to <code>Multis</code> is done by method provided by <code>multi.subscribe()</code>:</p>
</div>
<div class="listingblock">
<div class="title">Subscribing to Multis</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Multi&lt;String&gt; multi = Multi.createFrom().items("a", "b", "c");

Cancellable cancellable = multi.subscribe().with(
        item -&gt; System.out.println("Got " + item));
// you can use the returned Cancellable to cancel
// the computation
cancellable.cancel();

cancellable = multi.subscribe().with(
        item -&gt; System.out.println("Got " + item),
        failure -&gt; System.out.println("Got a failure: " + failure),
        () -&gt; System.out.println("Got the completion event"));

multi.subscribe().withSubscriber(new MultiSubscriber&lt;String&gt;() {
    @Override
    public void onSubscribe(Subscription s) {
        System.out.println("Got subscription: " + s);
    }

    @Override
    public void onItem(String item) {
        System.out.println("Got an item: " + item);
    }

    @Override
    public void onFailure(Throwable failure) {
        System.out.println("Got a failure: " + failure);
    }

    @Override
    public void onCompletion() {
        System.out.println("Got the completion event");
    }
});</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="structuring-the-pipeline"><a class="anchor" href="#structuring-the-pipeline"></a>Structuring the pipeline</h2>
<div class="sectionbody">
<div class="paragraph">
<p>It can be hard to structure your sequence of processing in a readable manner.
Mutiny provides the <code>stage</code> function to structure your pipeline:</p>
</div>
<div class="listingblock">
<div class="title">Structuring your pipeline with <code>stage</code></div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">String result = Multi.createFrom()
  .completionStage(CompletableFuture.supplyAsync(() -&gt; 23)
  )
  .stage(self -&gt; {
    // Transform each item into a string of the item +1
    return self
      .onItem().transform(i -&gt; i + 1)
      .onItem().transform(i -&gt; Integer.toString(i));
})
.stage(self -&gt; self
    .onItem().invoke(
      item -&gt; System.out.println("Item is " + item)
    )
    .collectItems().first())
.stage(self -&gt; self.await().indefinitely());</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>stage</code> can be used on <code>Multi</code> and <code>Uni</code> and let you group operations in a logical set.</p>
</div>
</div>
</div>
    </div>
    <div class="col-md-4 col-md-offset-1 toc-container" >
        <div class="page-toc affix-toc" data-offset-top="10" data-offset-bottom="200" data-spy="affix">
            <ul class="sectlevel1">
<li><a href="#concepts-philosophy">Concepts &amp; Philosophy</a>
<ul class="sectlevel2">
<li><a href="#why-is-asynchronous-important">Why is asynchronous important?</a></li>
<li><a href="#whats-reactive-programming">What&#8217;s Reactive Programming</a></li>
<li><a href="#what-makes-mutiny-different">What makes Mutiny different?</a></li>
<li><a href="#events">Events</a></li>
<li><a href="#an-event-driven-api">An event-driven API</a></li>
<li><a href="#uni-and-multi">Uni and Multi</a></li>
</ul>
</li>
<li><a href="#creating-and-subscribing-to-unis">Creating and Subscribing to Unis</a></li>
<li><a href="#creating-and-subscribing-to-multis">Creating and Subscribing to Multis</a></li>
<li><a href="#structuring-the-pipeline">Structuring the pipeline</a></li>
</ul>
        </div>
    </div>
</div>
 
</div>

            </div>

            <footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-lg-6 sep-right">
                <p>
                    SmallRye Mutiny is an open source project. All the code from this project is available under the Apache Software License 2.0.
                </p>
                <p>
                    This website was built with Jekyll, is hosted on Github Pages and is completely open source. If you want to make it better, fork the website and show us what you’ve got.
                </p>
            </div>
            <div class="col-lg-6">
                <p>
                     Site last generated: Nov 24, 2020
                </p>
            </div>
        </div>
    </div>
    <!-- Javascript-->
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.3.1/highlight.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ho+j7jyWK8fNQe+A12Hb8AhRq26LrZ/JpcUGGOn+Y7RsweNrtN/tE3MoK7ZeZDyx" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/gh/cferdinandi/gumshoe@4/dist/gumshoe.polyfills.min.js"></script>
    <script src="/mutiny-doc-sandbox/assets/js/hl.js" type="text/javascript"></script>
    <script src="/mutiny-doc-sandbox/assets/js/scrollspy.js" type="text/javascript"></script>
</footer>
        </main>
    </div>
</body>

</html>